<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HoloEarth – Blue Marble + RealEarth Clouds + Auto Brightness + City Lights – Hologram Pyramid</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; }

    /* IMPORTANT: ensure UI receives taps, not the canvas (Android fix) */
    canvas { pointer-events: none; }
    #uiWrap, #uiWrap * { pointer-events: auto; }

    #hud {
      position: fixed; left: 12px; top: 10px; color: #9aa;
      font: 12px/1.25 system-ui, Segoe UI, Arial, sans-serif;
      user-select:none; opacity:0.86;
      background: rgba(0,0,0,0.35); padding: 8px 10px; border-radius: 10px;
      max-width: calc(100vw - 24px);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    #hud b { color:#cfe; }

    /* ==========================================================
       OPTION 1: Touch controls overlay (Android-friendly)
       Refinements:
         (1) Auto-hide after 3s (activity resets timer)
         (2) Single Settings button expands/collapses
         (3) Presets (Bright / Demo / Night)
       ========================================================== */
    #uiWrap {
      position: fixed;
      right: 10px;
      bottom: 10px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    #uiBtn {
      width: 48px;
      height: 48px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.12);
      color: #fff;
      font: 18px/1 system-ui, Segoe UI, Arial, sans-serif;
      display: grid;
      place-items: center;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    }
    #uiPanel {
      display: none; /* collapsed by default */
      width: min(340px, calc(100vw - 20px));
      background: rgba(0,0,0,0.40);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px;
      color: #dbe;
      font: 12px/1.25 system-ui, Segoe UI, Arial, sans-serif;
      box-shadow: 0 10px 28px rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    #uiPanel .title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }
    #uiPanel .title b { color: #cfe; }
    #uiPanel .mini {
      opacity: 0.85;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 260px;
    }
    #uiPanel .row {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-top: 8px;
    }
    #uiPanel button {
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.12);
      color: #fff;
      border-radius: 10px;
      padding: 10px 8px;
      font: 14px/1 system-ui, Segoe UI, Arial, sans-serif;
    }
    #uiPanel button.wide { grid-column: span 2; }
    #uiPanel .status {
      opacity: 0.85;
      margin-top: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>
  <div id="hud">
    <b>HoloEarth</b> – Blue Marble + RealEarth clouds (globalvis.map day / IR night) + auto brightness + city lights
    • keys: [ / ] size, - / = speed, C refresh, H HUD, O/P vis, K/L ir, T sun mode, arrows move sun (manual), B/N brightness, M/, contrast<br/>
    Status: loading…
  </div>

  <!-- OPTION 1: Touch UI overlay (Android). Everything else unchanged. -->
  <div id="uiWrap" aria-label="Touch controls">
    <button id="uiBtn" title="Settings">⚙</button>

    <div id="uiPanel">
      <div class="title">
        <b>Controls</b>
        <div class="mini" id="uiMini">Ready</div>
      </div>

      <div class="row">
        <button data-cmd="bright+">☀+</button>
        <button data-cmd="bright-">☀−</button>
        <button data-cmd="contrast+">◐+</button>
        <button data-cmd="contrast-">◐−</button>
      </div>

      <div class="row">
        <button data-cmd="size+">Size+</button>
        <button data-cmd="size-">Size−</button>
        <button data-cmd="speed+">Speed+</button>
        <button data-cmd="speed-">Speed−</button>
      </div>

      <div class="row">
        <button data-cmd="vis+">Vis+</button>
        <button data-cmd="vis-">Vis−</button>
        <button data-cmd="ir+">IR+</button>
        <button data-cmd="ir-">IR−</button>
      </div>

      <div class="row">
        <button data-cmd="sunToggle">Sun</button>
        <button data-cmd="sunLeft">←</button>
        <button data-cmd="sunRight">→</button>
        <button data-cmd="sunUp">↑</button>
      </div>

      <div class="row">
        <button data-cmd="sunDown">↓</button>
        <button data-cmd="refresh">☁</button>
        <button data-cmd="hud">HUD</button>
        <button data-cmd="close">Close</button>
      </div>

      <div class="row">
        <button class="wide" data-cmd="presetBright">Bright</button>
        <button class="wide" data-cmd="presetDemo">Demo</button>
      </div>
      <div class="row">
        <button class="wide" data-cmd="presetNight">Night</button>
        <button class="wide" data-cmd="presetReset">Reset</button>
      </div>

      <div class="row">
        <button data-cmd="clockBright+">Clk+</button>
        <button data-cmd="clockBright-">Clk−</button>
        <button data-cmd="clockSize+">ClkSize+</button>
        <button data-cmd="clockSize-">ClkSize−</button>
      </div>

      <div class="status" id="uiStatus">Ready</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // =========================
    // SETTINGS
    // =========================
    const BLUE_MARBLE_LOCAL = "./bluemarble-2048.png";
    const CITY_LIGHTS_URL   = "./earth_lights_2048.png";

    const REALEARTH_MAPSERV    = "https://realearth.ssec.wisc.edu/cgi-bin/mapserv";
    const REALEARTH_ACCESS_KEY = "cf32a5095a8af165443447441e16b226";

    // HARD PIN: no TSP / no fallback
    const VIS_MAPFILE = "globalvis.map";
    const VIS_LAYER   = "latest";
    const IR_MAPFILE  = "globalir.map";
    const IR_LAYER    = "latest";

    const CLOUD_W = 1024;
    const CLOUD_H = 512;
    const CLOUD_REFRESH_MINUTES = 60;

    // Visual tuning
    let visOpacity = 0.80;          // O/P
    let irOpacity  = 0.55;          // K/L
    let terminatorSoftness = 0.10;  // 0.05–0.15
    let irAlphaFloor = 0.04;        // prevents holes where IR is dark/no-data

    // Contrast tweak (visible luminance shaping)
    const VIS_CONTRAST_GAMMA = 1.35; // 1.2–1.6 typical

    // Hologram tuning
    let globeScale = 0.88;          // [ / ]
    let spinSpeed  = 0.15;          // - / =

    // =========================
    // CONSTANT LONGITUDE SHIFT (move seam to mid-Atlantic)
    // =========================
    // Target seam longitude (degrees). -30 means ~30°W, middle Atlantic.
    const SEAM_LON_DEG = -30;

    // Convert seam target to UV shift.
    // Original equirectangular: u = (lon + 180) / 360.
    // We want lon=SEAM_LON_DEG to land at u=0 seam => u' = u - u0.
    // Use positive wrap: LON_SHIFT_U in [0..1).
    const LON_SHIFT_U = (1 - ((SEAM_LON_DEG + 180) / 360)) % 1;

    // =========================
    // FINAL OUTPUT BRIGHTENING
    // =========================
    let FINAL_GAIN = 1.70;      // B/N keys adjust. Try 1.4–2.2
    let FINAL_CONTRAST = 1.08;  // M/, keys adjust. Try 1.0–1.2
 
     // =========================
     // DIGITAL CLOCK (hologram overlay)
     // =========================
     // Position is in face-space, relative to the face size:
     //   X: -1 (left edge) .. 0 (center) .. +1 (right edge)
     //   Y: -1 (top edge)  .. 0 (center) .. +1 (bottom edge)
     // Start in the middle of the globe (0,0). Tweak these to experiment.
     let CLOCK_POS_X = 0.0;
     let CLOCK_POS_Y = 0.0;
 
     // Brightness (opacity) and size controls for the clock:
     // - CLOCK_BRIGHTNESS: 0..1
     // - CLOCK_SCALE: ~0.5..3
     let CLOCK_BRIGHTNESS = 0.55; // keys: 1/2, touch: Clock+ / Clock-
     let CLOCK_SCALE      = 1.00; // keys: 3/4, touch: Size+ / Size-

    // =========================
    // Bright preset (scene + auto brightness)
    // =========================
    const SUN_INTENSITY_DAY      = 2.2;
    const AMBIENT_INTENSITY_DAY  = 0.60;

    const SUN_INTENSITY_NIGHT      = 1.0;
    const AMBIENT_INTENSITY_NIGHT  = 0.95;

    const CLOUD_GAIN_DAY   = 1.20;
    const CLOUD_GAIN_NIGHT = 1.70;

    const CITY_GAIN_DAY    = 0.00;
    const CITY_GAIN_NIGHT  = 2.00;

    // =========================
    // HUD helper
    // =========================
    const hud = document.getElementById("hud");
    hud.style.display = "none"; // hidden by default (H toggles)

    function setStatus(msg) {
      const lines = hud.innerHTML.split("<br/>");
      hud.innerHTML = `${lines[0]}<br/>Status: ${msg}`;
      // Also mirror to touch UI status (if present)
      const uiStatus = document.getElementById("uiStatus");
      const uiMini = document.getElementById("uiMini");
      if (uiStatus) uiStatus.textContent = msg;
      if (uiMini) uiMini.textContent = msg;
    }

    // =========================
    // RealEarth URL builder
    // =========================
    function realEarthGetMapUrl({ mapfile, layer }) {
      const params = new URLSearchParams({
        map: mapfile,
        service: "wms",
        version: "1.3.0",
        request: "GetMap",
        layers: layer,
        crs: "EPSG:4326",
        bbox: "-90,-179.999,90,179.999",
        width: String(CLOUD_W),
        height: String(CLOUD_H),
        format: "image/png",
        transparent: "true",
        accesskey: REALEARTH_ACCESS_KEY
      });
      params.set("t", String(Date.now()));
      return `${REALEARTH_MAPSERV}?${params.toString()}`;
    }

    async function loadImage(url) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      return new Promise((resolve, reject) => {
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    // =========================
    // Canvas helpers
    // =========================
    function makeCanvasFromImage(img, w, h) {
      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const cx = c.getContext("2d", { alpha: true });
      cx.clearRect(0, 0, w, h);
      cx.drawImage(img, 0, 0, w, h);
      return c;
    }

    // Seam-safe wrap by copying edge pixels (no blending).
    function bleedWrapEdges(canvas, bleedPx = 16) {
      const w = canvas.width, h = canvas.height;
      const ctx = canvas.getContext("2d", { alpha: true });

      const px = Math.max(1, Math.min(bleedPx | 0, Math.floor(w / 4)));

      const img = ctx.getImageData(0, 0, w, h);
      const d = img.data;

      function copyCol(srcX, dstX) {
        for (let y = 0; y < h; y++) {
          const si = (y * w + srcX) * 4;
          const di = (y * w + dstX) * 4;
          d[di]   = d[si];
          d[di+1] = d[si+1];
          d[di+2] = d[si+2];
          d[di+3] = d[si+3];
        }
      }

      for (let i = 0; i < px; i++) copyCol(i, w - px + i);
      for (let i = 0; i < px; i++) copyCol(w - px + i, i);

      ctx.putImageData(img, 0, 0);
      return canvas;
    }

    function canvasToCloudTexture(c) {
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = 8;
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.generateMipmaps = false;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      // keep half-texel offset in shader (uUOffset), not here
      tex.needsUpdate = true;
      return tex;
    }

    function canvasToBaseTexture(c) {
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = 8;
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.generateMipmaps = false;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      // Apply seam shift + half texel offset for THREE's built-in UV sampling
      tex.offset.x = LON_SHIFT_U + (0.5 / c.width);
      tex.needsUpdate = true;
      return tex;
    }

    // =========================
    // THREE.JS SETUP
    // =========================
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const cam = new THREE.PerspectiveCamera(35, 1, 0.1, 100);
    cam.position.set(0, 0, 4.3);

    const sunLight = new THREE.DirectionalLight(0xffffff, SUN_INTENSITY_DAY);
    sunLight.position.set(3, 1.2, 2.5);
    scene.add(sunLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, AMBIENT_INTENSITY_DAY);
    scene.add(ambientLight);

    // =========================
    // SUN CONTROL MODES
    // =========================
    const SunMode = Object.freeze({ REAL: "REAL", MANUAL: "MANUAL" });
    let sunMode = SunMode.REAL;

    let sunLon = 0;  // -180..180
    let sunLat = 0;  //  -89..89

    function setSunFromLonLat(lonDeg, latDeg) {
      sunLon = ((lonDeg + 540) % 360) - 180;
      sunLat = Math.max(-89, Math.min(89, latDeg));

      const lon = THREE.MathUtils.degToRad(sunLon);
      const lat = THREE.MathUtils.degToRad(sunLat);

      const x = Math.cos(lat) * Math.cos(lon);
      const y = Math.sin(lat);
      const z = Math.cos(lat) * Math.sin(lon);

      sunLight.position.set(x, y, z).normalize().multiplyScalar(5);
    }

    function updateSunFromDate(date = new Date()) {
      const rad = Math.PI / 180;
      const dayMs = 86400000;
      const d = (date.getTime() - Date.UTC(2000,0,1,12,0,0)) / dayMs;

      const g = (357.529 + 0.98560028 * d) * rad;
      const q = (280.459 + 0.98564736 * d) * rad;

      const L = q + (1.915 * Math.sin(g) + 0.020 * Math.sin(2*g)) * rad;
      const e = 23.439 * rad;

      const x = Math.cos(L);
      const y = Math.sin(L) * Math.cos(e);
      const z = Math.sin(L) * Math.sin(e);

      sunLight.position.set(x, y, z).normalize().multiplyScalar(5);
    }

    function syncManualFromCurrentSun() {
      const v = sunLight.position.clone().normalize();
      const lat = Math.asin(v.y);
      const lon = Math.atan2(v.z, v.x);
      setSunFromLonLat(THREE.MathUtils.radToDeg(lon), THREE.MathUtils.radToDeg(lat));
    }

    updateSunFromDate(new Date());
    setInterval(() => { if (sunMode === SunMode.REAL) updateSunFromDate(new Date()); }, 60 * 1000);

    // =========================
    // Base globe (seam-safe + shifted to Atlantic seam)
    // =========================
    const globeGeo = new THREE.SphereGeometry(1, 96, 96);

    const baseImg = await loadImage(BLUE_MARBLE_LOCAL);
    const baseW = (baseImg.naturalWidth || baseImg.width);
    const baseH = (baseImg.naturalHeight || baseImg.height);
    const baseCanvas = bleedWrapEdges(makeCanvasFromImage(baseImg, baseW, baseH), 16);
    const baseTex = canvasToBaseTexture(baseCanvas);

    const globe = new THREE.Mesh(
      globeGeo,
      new THREE.MeshPhongMaterial({ map: baseTex, shininess: 8, specular: 0x111111 })
    );
    scene.add(globe);

    // =========================
    // City lights sphere (seam-safe + shifted to Atlantic seam)
    // =========================
    const cityImg = await loadImage(CITY_LIGHTS_URL);
    const cityW = (cityImg.naturalWidth || cityImg.width);
    const cityH = (cityImg.naturalHeight || cityImg.height);
    const cityCanvas = bleedWrapEdges(makeCanvasFromImage(cityImg, cityW, cityH), 16);
    const cityTex = canvasToBaseTexture(cityCanvas); // includes LON_SHIFT_U

    const cityUniforms = {
      uNightMap: { value: cityTex },
      uSunDir:   { value: new THREE.Vector3(1,0,0) },
      uSoftness: { value: terminatorSoftness },
      uGain:     { value: 0.0 },
      uUOffset:  { value: 0.5 / cityCanvas.width },
      uLonShift: { value: LON_SHIFT_U }
    };

    const cityMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: cityUniforms,
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vWorldNormal;
        void main() {
          vUv = uv;
          vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D uNightMap;
        uniform vec3 uSunDir;
        uniform float uSoftness;
        uniform float uGain;
        uniform float uUOffset;
        uniform float uLonShift;

        varying vec2 vUv;
        varying vec3 vWorldNormal;

        float lum(vec3 c){ return dot(c, vec3(0.2126,0.7152,0.0722)); }

        void main() {
          // Wrap U with half-texel + constant lon shift
          vec2 uv = vec2(fract(vUv.x + uUOffset + uLonShift), vUv.y);

          vec3 n = normalize(vWorldNormal);
          vec3 s = normalize(uSunDir);
          float d = dot(n, s);

          float dayW   = smoothstep(-uSoftness, uSoftness, d);
          float nightW = 1.0 - dayW;

          vec3 nightRGB = texture2D(uNightMap, uv).rgb;

          float a = clamp(lum(nightRGB) * 2.0, 0.0, 1.0);
          float outA = nightW * a * uGain;
          if (outA <= 0.001) discard;

          gl_FragColor = vec4(nightRGB * uGain, outA);
        }
      `
    });

    const citySphere = new THREE.Mesh(new THREE.SphereGeometry(1.001, 96, 96), cityMat);
    scene.add(citySphere);

    // =========================
    // Cloud sphere shader (visible day + IR night blend)
    // =========================
    const cloudUniforms = {
      uVisMap:      { value: null },
      uIrMap:       { value: null },
      uSunDir:      { value: new THREE.Vector3(1,0,0) },
      uSoftness:    { value: terminatorSoftness },
      uVisOpacity:  { value: visOpacity },
      uIrOpacity:   { value: irOpacity },
      uIrFloor:     { value: irAlphaFloor },
      uUOffset:     { value: 0.5 / CLOUD_W },
      uLonShift:    { value: LON_SHIFT_U },
      uVisGamma:    { value: VIS_CONTRAST_GAMMA },
      uCloudGainDay:{ value: CLOUD_GAIN_DAY },
      uCloudGainNight:{ value: CLOUD_GAIN_NIGHT }
    };

    const cloudMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      uniforms: cloudUniforms,
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vWorldNormal;
        void main() {
          vUv = uv;
          vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D uVisMap;
        uniform sampler2D uIrMap;
        uniform vec3  uSunDir;
        uniform float uSoftness;
        uniform float uVisOpacity;
        uniform float uIrOpacity;
        uniform float uIrFloor;
        uniform float uUOffset;
        uniform float uLonShift;
        uniform float uVisGamma;
        uniform float uCloudGainDay;
        uniform float uCloudGainNight;

        varying vec2 vUv;
        varying vec3 vWorldNormal;

        float lum(vec3 c){ return dot(c, vec3(0.2126,0.7152,0.0722)); }

        void main() {
          vec2 uv = vec2(fract(vUv.x + uUOffset + uLonShift), vUv.y);

          vec3 n = normalize(vWorldNormal);
          vec3 s = normalize(uSunDir);
          float d = dot(n, s);
          float dayW = smoothstep(-uSoftness, uSoftness, d);
          float nightW = 1.0 - dayW;

          vec4 vis = texture2D(uVisMap, uv);
          vec4 ir  = texture2D(uIrMap,  uv);

          // Visible "contrast tweak": gamma on luminance and rebuild
          vec3 visRGB = vis.rgb;
          float vL = lum(visRGB);
          vL = pow(max(vL, 0.0001), uVisGamma);
          visRGB *= (vL / max(lum(visRGB), 0.0001));

          // Gains for day/night cloud visibility
          float cloudGain = mix(uCloudGainNight, uCloudGainDay, dayW);

          // Use alpha derived from luminance (better than raw alpha)
          float visA = clamp(lum(visRGB) * 2.2, 0.0, 1.0) * uVisOpacity;
          float irA  = clamp(lum(ir.rgb)    * 2.2, 0.0, 1.0) * uIrOpacity;

          // Floor IR alpha so the "dark/no-data" doesn't punch holes
          irA = max(irA, uIrFloor * uIrOpacity);

          // Blend maps by day/night weight, but keep some of both
          vec3 rgb = mix(ir.rgb, visRGB, dayW);
          float a  = mix(irA, visA, dayW);

          // Apply gain (overall cloud strength)
          rgb *= cloudGain;
          a   = clamp(a * cloudGain, 0.0, 1.0);

          if (a <= 0.001) discard;
          gl_FragColor = vec4(rgb, a);
        }
      `
    });

    const cloudSphere = new THREE.Mesh(new THREE.SphereGeometry(1.006, 96, 96), cloudMat);
    scene.add(cloudSphere);

    // =========================
    // Fetch clouds (seam-safe + shifted)
    // =========================
    async function refreshClouds() {
      const urlVis = realEarthGetMapUrl({ mapfile: VIS_MAPFILE, layer: VIS_LAYER });
      const urlIr  = realEarthGetMapUrl({ mapfile: IR_MAPFILE,  layer: IR_LAYER  });

      setStatus(`Fetching clouds…`);

      try {
        const [visImg, irImg] = await Promise.all([loadImage(urlVis), loadImage(urlIr)]);

        const visCanvas = bleedWrapEdges(makeCanvasFromImage(visImg, CLOUD_W, CLOUD_H), 16);
        const irCanvas  = bleedWrapEdges(makeCanvasFromImage(irImg,  CLOUD_W, CLOUD_H), 16);

        cloudUniforms.uVisMap.value = canvasToCloudTexture(visCanvas);
        cloudUniforms.uIrMap.value  = canvasToCloudTexture(irCanvas);

        setStatus("OK – Clouds updated.");
      } catch (err) {
        console.error("Cloud fetch failed:", err);
        setStatus("Cloud fetch failed (see console).");
      }
    }

    await refreshClouds();
    setInterval(refreshClouds, CLOUD_REFRESH_MINUTES * 60 * 1000);

    // =========================
    // Viewer position (top/bottom)
    // =========================
    const ViewerMode = Object.freeze({ TOP: "TOP", BOTTOM: "BOTTOM" });
    let viewerMode = ViewerMode.BOTTOM;

    function toggleViewerMode() {
      viewerMode = (viewerMode === ViewerMode.BOTTOM) ? ViewerMode.TOP : ViewerMode.BOTTOM;
      setStatus(`Viewer: ${viewerMode === ViewerMode.TOP ? "Top (screen below viewer)" : "Bottom (screen above viewer)"}`);
    }

    // =========================
    // Offscreen render target (square view for hologram)
    // =========================
    const rtSize = 1024;
    const rt = new THREE.WebGLRenderTarget(rtSize, rtSize, { depthBuffer: true, stencilBuffer: false });
    rt.texture.colorSpace = THREE.SRGBColorSpace;

    // Output canvas for hologram layout
    const out = document.createElement("canvas");
    const ctx = out.getContext("2d", { alpha: false });
    document.body.appendChild(out);

    renderer.domElement.style.position = "fixed";
    renderer.domElement.style.left = "-10000px";
    renderer.domElement.style.top = "0";

    function resize() { out.width = window.innerWidth; out.height = window.innerHeight; }
    window.addEventListener("resize", resize);
    resize();

    // =========================
    // DIGITAL CLOCK rendering (drawn on each face; does not rotate with the face)
    // =========================
    function getLocalClockString() {
      // Local time, seconds included for a "digital clock" feel
      const d = new Date();
      const hh = String(d.getHours()).padStart(2, "0");
      const mm = String(d.getMinutes()).padStart(2, "0");
      const ss = String(d.getSeconds()).padStart(2, "0");
      return `${hh}:${mm}:${ss}`;
    }

    function drawClockOnFace(side) {
      // Draw in unrotated face-space coordinates (so it stays upright on-screen)
      const t = getLocalClockString();

      const alpha = Math.max(0, Math.min(1, CLOCK_BRIGHTNESS));
      if (alpha <= 0.001) return;

      const s = Math.max(0.2, CLOCK_SCALE);
      const fontPx = Math.max(14, Math.floor(side * 0.095 * s));

      // Face-space position in pixels
      const x = (CLOCK_POS_X * 0.5) * side;
      const y = (CLOCK_POS_Y * 0.5) * side;

      ctx.save();
      ctx.translate(x, y);

      // If viewer is ABOVE the screen (TOP mode), the pyramid reflection flips;
      // pre-flip the clock so it reads correctly in the hologram.
      if (viewerMode === ViewerMode.TOP) ctx.scale(1, -1);

      ctx.font = `700 ${fontPx}px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // Soft background bar for readability
      const padX = Math.floor(fontPx * 0.6);
      const padY = Math.floor(fontPx * 0.32);
      const metrics = ctx.measureText(t);
      const bw = Math.ceil(metrics.width + padX * 2);
      const bh = Math.ceil(fontPx + padY * 2);

      ctx.fillStyle = `rgba(0,0,0,${0.35 * alpha})`;
      roundRect(ctx, -bw/2, -bh/2, bw, bh, Math.max(10, Math.floor(fontPx * 0.3)));
      ctx.fill();

      // Glow + text
      ctx.shadowColor = `rgba(255,255,255,${0.55 * alpha})`;
      ctx.shadowBlur = Math.floor(fontPx * 0.35);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fillText(t, 0, 0);

      ctx.restore();
    }

    function roundRect(c, x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      c.beginPath();
      c.moveTo(x + rr, y);
      c.arcTo(x + w, y, x + w, y + h, rr);
      c.arcTo(x + w, y + h, x, y + h, rr);
      c.arcTo(x, y + h, x, y, rr);
      c.arcTo(x, y, x + w, y, rr);
      c.closePath();
    }

    // =========================
    // Draw hologram pyramid layout (4 faces)
    // =========================
    function drawHologramLayout(imgCanvas) {
      const w = out.width, h = out.height;
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, w, h);

      const side = Math.floor(Math.min(w, h) * 0.48 * globeScale);
      const cx = w / 2, cy = h / 2;

      const pos = {
        top:    { x: cx, y: cy - side * 0.78, rot: Math.PI },
        bottom: { x: cx, y: cy + side * 0.78, rot: 0 },
        left:   { x: cx - side * 0.78, y: cy, rot: Math.PI / 2 },
        right:  { x: cx + side * 0.78, y: cy, rot: -Math.PI / 2 }
      };

      function blit(p) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);

        ctx.filter = `brightness(${FINAL_GAIN}) contrast(${FINAL_CONTRAST})`;
        ctx.drawImage(imgCanvas, -side/2, -side/2, side, side);
        ctx.filter = "none";

        // Clock overlay (upright on-screen; shown on all faces)
        ctx.save();
        ctx.rotate(-p.rot);
        drawClockOnFace(side);
        ctx.restore();

        ctx.restore();
      }

      blit(pos.top); blit(pos.left); blit(pos.right); blit(pos.bottom);
    }

    // =========================
    // Render loop
    // =========================
    const viewCanvas = document.createElement("canvas");
    viewCanvas.width = rtSize;
    viewCanvas.height = rtSize;
    const viewCtx = viewCanvas.getContext("2d", { alpha: false });

    function computeDayFraction() {
      const s = sunLight.position.clone().normalize();
      // Approx "noon point" in view space; use globe normal towards sun.
      // Day fraction roughly maps to how much of the visible hemisphere is lit.
      // We'll just use sun direction Z as a proxy for day/night weighting.
      return Math.max(0, Math.min(1, (s.z + 1) * 0.5));
    }

    function updateAutoBrightness(dayFrac) {
      const t = dayFrac; // 0=night, 1=day

      sunLight.intensity = SUN_INTENSITY_NIGHT + (SUN_INTENSITY_DAY - SUN_INTENSITY_NIGHT) * t;
      ambientLight.intensity = AMBIENT_INTENSITY_NIGHT + (AMBIENT_INTENSITY_DAY - AMBIENT_INTENSITY_NIGHT) * t;

      // City lights only at night
      cityUniforms.uGain.value = CITY_GAIN_NIGHT + (CITY_GAIN_DAY - CITY_GAIN_NIGHT) * t;

      // Clouds gain (stronger at night to show IR)
      cloudUniforms.uCloudGainNight.value = CLOUD_GAIN_NIGHT;
      cloudUniforms.uCloudGainDay.value = CLOUD_GAIN_DAY;
    }

    let lastT = performance.now();
    function animate(now) {
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, (now - lastT) / 1000);
      lastT = now;

      // Sun vector into shaders
      const s = sunLight.position.clone().normalize();
      cloudUniforms.uSunDir.value.copy(s);
      cityUniforms.uSunDir.value.copy(s);
      cloudUniforms.uSoftness.value = terminatorSoftness;
      cityUniforms.uSoftness.value = terminatorSoftness;

      // Auto brightness based on approximate day fraction
      const dayFrac = computeDayFraction();
      updateAutoBrightness(dayFrac);

      // Spin globe
      const dir = (viewerMode === ViewerMode.TOP) ? -1 : +1;
      globe.rotation.y += dir * spinSpeed * dt;
      citySphere.rotation.copy(globe.rotation);
      cloudSphere.rotation.copy(globe.rotation);

      // Render offscreen
      renderer.setRenderTarget(rt);
      renderer.setSize(rtSize, rtSize, false);
      cam.aspect = 1;
      cam.updateProjectionMatrix();
      renderer.render(scene, cam);
      renderer.setRenderTarget(null);

      // Copy RT to a 2D canvas
      renderer.readRenderTargetPixels(rt, 0, 0, rtSize, rtSize, new Uint8Array(rtSize * rtSize * 4));
      // Faster path: draw from renderer canvas via toDataURL is slow; instead use drawImage(renderer.domElement)
      // We rendered offscreen, so use renderer.domElement by temporarily rendering to screen is avoided;
      // Alternative: use WebGLRenderer.domElement still updated. We'll just draw it:
      viewCtx.fillStyle = "#000";
      viewCtx.fillRect(0, 0, rtSize, rtSize);
      viewCtx.drawImage(renderer.domElement, 0, 0, rtSize, rtSize);

      // Hologram layout
      drawHologramLayout(viewCanvas);
    }
    requestAnimationFrame(animate);

    // =========================
    // Keyboard controls
    // =========================
    window.addEventListener("keydown", (e) => {
      if (e.key === "h" || e.key === "H") hud.style.display = (hud.style.display === "none" ? "" : "none");
      if (e.key === "[") globeScale = Math.max(0.55, globeScale - 0.03);
      if (e.key === "]") globeScale = Math.min(1.15, globeScale + 0.03);
      if (e.key === "-") spinSpeed = Math.max(0.02, spinSpeed - 0.03);
      if (e.key === "=") spinSpeed = Math.min(1.2,  spinSpeed + 0.03);
      if (e.key === "c" || e.key === "C") refreshClouds();
      if (e.key === "v" || e.key === "V") toggleViewerMode();

      if (e.key === "o" || e.key === "O") { visOpacity = Math.min(1.0, visOpacity + 0.05); cloudUniforms.uVisOpacity.value = visOpacity; setStatus(`Visible opacity ${Math.round(visOpacity*100)}%`); }
      if (e.key === "p" || e.key === "P") { visOpacity = Math.max(0.0, visOpacity - 0.05); cloudUniforms.uVisOpacity.value = visOpacity; setStatus(`Visible opacity ${Math.round(visOpacity*100)}%`); }

      if (e.key === "k" || e.key === "K") { irOpacity  = Math.min(1.0, irOpacity  + 0.05); cloudUniforms.uIrOpacity.value  = irOpacity;  setStatus(`IR opacity ${Math.round(irOpacity*100)}%`); }
      if (e.key === "l" || e.key === "L") { irOpacity  = Math.max(0.0, irOpacity  - 0.05); cloudUniforms.uIrOpacity.value  = irOpacity;  setStatus(`IR opacity ${Math.round(irOpacity*100)}%`); }

      if (e.key === "b" || e.key === "B") { FINAL_GAIN = Math.min(3.0, FINAL_GAIN + 0.10); setStatus(`FINAL brightness gain: ${FINAL_GAIN.toFixed(2)}`); }
      if (e.key === "n" || e.key === "N") { FINAL_GAIN = Math.max(0.5, FINAL_GAIN - 0.10); setStatus(`FINAL brightness gain: ${FINAL_GAIN.toFixed(2)}`); }

      if (e.key === "m" || e.key === "M") { FINAL_CONTRAST = Math.min(2.0, FINAL_CONTRAST + 0.05); setStatus(`FINAL contrast: ${FINAL_CONTRAST.toFixed(2)}`); }
      if (e.key === "," )                 { FINAL_CONTRAST = Math.max(0.8, FINAL_CONTRAST - 0.05); setStatus(`FINAL contrast: ${FINAL_CONTRAST.toFixed(2)}`); }

      // Clock controls (works on desktop + Android keyboard)
      if (e.key === "1") { CLOCK_BRIGHTNESS = Math.min(1.0, CLOCK_BRIGHTNESS + 0.05); setStatus(`Clock brightness: ${Math.round(CLOCK_BRIGHTNESS*100)}%`); }
      if (e.key === "2") { CLOCK_BRIGHTNESS = Math.max(0.0, CLOCK_BRIGHTNESS - 0.05); setStatus(`Clock brightness: ${Math.round(CLOCK_BRIGHTNESS*100)}%`); }
      if (e.key === "3") { CLOCK_SCALE = Math.min(3.0, CLOCK_SCALE + 0.10); setStatus(`Clock size: ${CLOCK_SCALE.toFixed(2)}×`); }
      if (e.key === "4") { CLOCK_SCALE = Math.max(0.4, CLOCK_SCALE - 0.10); setStatus(`Clock size: ${CLOCK_SCALE.toFixed(2)}×`); }

      if (e.key === "t" || e.key === "T") {
        if (sunMode === SunMode.REAL) {
          sunMode = SunMode.MANUAL;
          syncManualFromCurrentSun();
          setStatus(`Sun mode: MANUAL (arrows adjust). Lon=${sunLon.toFixed(0)} Lat=${sunLat.toFixed(0)}`);
        } else {
          sunMode = SunMode.REAL;
          updateSunFromDate(new Date());
          setStatus(`Sun mode: REAL (UTC now)`);
        }
      }

      if (sunMode === SunMode.MANUAL) {
        if (e.key === "ArrowLeft")  { sunLon -= 5; setSunFromLonLat(sunLon, sunLat); setStatus(`Sun Lon=${sunLon.toFixed(0)} Lat=${sunLat.toFixed(0)}`); }
        if (e.key === "ArrowRight") { sunLon += 5; setSunFromLonLat(sunLon, sunLat); setStatus(`Sun Lon=${sunLon.toFixed(0)} Lat=${sunLat.toFixed(0)}`); }
        if (e.key === "ArrowUp")    { sunLat += 3; setSunFromLonLat(sunLon, sunLat); setStatus(`Sun Lon=${sunLon.toFixed(0)} Lat=${sunLat.toFixed(0)}`); }
        if (e.key === "ArrowDown")  { sunLat -= 3; setSunFromLonLat(sunLon, sunLat); setStatus(`Sun Lon=${sunLon.toFixed(0)} Lat=${sunLat.toFixed(0)}`); }
      }
    });

    // =========================
    // Touch UI (Option 1)
    // =========================
    (function initTouchUI() {
      const uiWrap = document.getElementById("uiWrap");
      const uiBtn = document.getElementById("uiBtn");
      const uiPanel = document.getElementById("uiPanel");
      const uiStatus = document.getElementById("uiStatus");
      const uiMini = document.getElementById("uiMini");

      let hideTimer = null;
      const AUTOHIDE_MS = 3000;

      function uiSetStatus(msg) {
        if (uiStatus) uiStatus.textContent = msg;
        if (uiMini) uiMini.textContent = msg;
      }

      function showPanel() {
        uiPanel.style.display = "";
        armAutoHide();
      }
      function hidePanel() {
        uiPanel.style.display = "none";
        disarmAutoHide();
      }
      function togglePanel() {
        if (uiPanel.style.display === "none" || uiPanel.style.display === "") {
          // If currently none, show. If empty, it's visible.
          if (uiPanel.style.display === "none") showPanel();
          else hidePanel();
        } else {
          // Fallback
          showPanel();
        }
      }

      function armAutoHide() {
        if (!uiPanel || uiPanel.style.display === "none") return;
        if (hideTimer) clearTimeout(hideTimer);
        hideTimer = setTimeout(() => hidePanel(), AUTOHIDE_MS);
      }
      function disarmAutoHide() {
        if (hideTimer) clearTimeout(hideTimer);
        hideTimer = null;
      }

      uiBtn.addEventListener("click", (e) => {
        e.preventDefault();
        if (uiPanel.style.display === "none") showPanel();
        else hidePanel();
      }, { passive: false });

      uiPanel.addEventListener("click", async (e) => {
        const t = e.target;
        if (!(t instanceof HTMLElement)) return;
        const cmd = t.getAttribute("data-cmd");
        if (!cmd) return;
        e.preventDefault();
        await runCmd(cmd);
      }, { passive: false });

      async function runCmd(cmd) {
        armAutoHide();

        switch (cmd) {
          case "close":
            hidePanel();
            return;

          case "viewerToggle":
            toggleViewerMode();
            uiSetStatus(`Viewer: ${viewerMode === ViewerMode.TOP ? "Top" : "Bottom"}`);
            return;

          case "hud":
            hud.style.display = (hud.style.display === "none" ? "" : "none");
            uiSetStatus(`HUD: ${hud.style.display === "none" ? "off" : "on"}`);
            return;

          case "refresh":
            uiSetStatus("Refreshing clouds…");
            await refreshClouds();
            uiSetStatus("Clouds refreshed");
            return;

          case "bright+":
            FINAL_GAIN = Math.min(3.0, FINAL_GAIN + 0.10);
            uiSetStatus(`Brightness gain: ${FINAL_GAIN.toFixed(2)}`);
            return;

          case "bright-":
            FINAL_GAIN = Math.max(0.5, FINAL_GAIN - 0.10);
            uiSetStatus(`Brightness gain: ${FINAL_GAIN.toFixed(2)}`);
            return;

          case "contrast+":
            FINAL_CONTRAST = Math.min(2.0, FINAL_CONTRAST + 0.05);
            uiSetStatus(`Contrast: ${FINAL_CONTRAST.toFixed(2)}`);
            return;

          case "contrast-":
            FINAL_CONTRAST = Math.max(0.8, FINAL_CONTRAST - 0.05);
            uiSetStatus(`Contrast: ${FINAL_CONTRAST.toFixed(2)}`);
            return;

          case "clockBright+":
            CLOCK_BRIGHTNESS = Math.min(1.0, CLOCK_BRIGHTNESS + 0.05);
            uiSetStatus(`Clock brightness: ${Math.round(CLOCK_BRIGHTNESS*100)}%`);
            return;

          case "clockBright-":
            CLOCK_BRIGHTNESS = Math.max(0.0, CLOCK_BRIGHTNESS - 0.05);
            uiSetStatus(`Clock brightness: ${Math.round(CLOCK_BRIGHTNESS*100)}%`);
            return;

          case "clockSize+":
            CLOCK_SCALE = Math.min(3.0, CLOCK_SCALE + 0.10);
            uiSetStatus(`Clock size: ${CLOCK_SCALE.toFixed(2)}×`);
            return;

          case "clockSize-":
            CLOCK_SCALE = Math.max(0.4, CLOCK_SCALE - 0.10);
            uiSetStatus(`Clock size: ${CLOCK_SCALE.toFixed(2)}×`);
            return;

          case "size+":
            globeScale = Math.min(1.15, globeScale + 0.03);
            uiSetStatus(`Size: ${globeScale.toFixed(2)}`);
            return;

          case "size-":
            globeScale = Math.max(0.55, globeScale - 0.03);
            uiSetStatus(`Size: ${globeScale.toFixed(2)}`);
            return;

          case "speed+":
            spinSpeed = Math.min(1.2, spinSpeed + 0.03);
            uiSetStatus(`Speed: ${spinSpeed.toFixed(2)}`);
            return;

          case "speed-":
            spinSpeed = Math.max(0.02, spinSpeed - 0.03);
            uiSetStatus(`Speed: ${spinSpeed.toFixed(2)}`);
            return;

          case "vis+":
            visOpacity = Math.min(1.0, visOpacity + 0.05);
            cloudUniforms.uVisOpacity.value = visOpacity;
            uiSetStatus(`Visible: ${Math.round(visOpacity*100)}%`);
            return;

          case "vis-":
            visOpacity = Math.max(0.0, visOpacity - 0.05);
            cloudUniforms.uVisOpacity.value = visOpacity;
            uiSetStatus(`Visible: ${Math.round(visOpacity*100)}%`);
            return;

          case "ir+":
            irOpacity = Math.min(1.0, irOpacity + 0.05);
            cloudUniforms.uIrOpacity.value = irOpacity;
            uiSetStatus(`IR: ${Math.round(irOpacity*100)}%`);
            return;

          case "ir-":
            irOpacity = Math.max(0.0, irOpacity - 0.05);
            cloudUniforms.uIrOpacity.value = irOpacity;
            uiSetStatus(`IR: ${Math.round(irOpacity*100)}%`);
            return;

          case "sunToggle":
            if (sunMode === SunMode.REAL) {
              sunMode = SunMode.MANUAL;
              syncManualFromCurrentSun();
              uiSetStatus(`Sun: MANUAL`);
            } else {
              sunMode = SunMode.REAL;
              updateSunFromDate(new Date());
              uiSetStatus(`Sun: REAL`);
            }
            return;

          case "sunLeft":
            if (sunMode === SunMode.MANUAL) { sunLon -= 5; setSunFromLonLat(sunLon, sunLat); uiSetStatus(`Sun Lon=${sunLon.toFixed(0)} Lat=${sunLat.toFixed(0)}`); }
            return;

          case "sunRight":
            if (sunMode === SunMode.MANUAL) { sunLon += 5; setSunFromLonLat(sunLon, sunLat); uiSetStatus(`Sun Lon=${sunLon.toFixed(0)} Lat=${sunLat.toFixed(0)}`); }
            return;

          case "sunUp":
            if (sunMode === SunMode.MANUAL) { sunLat += 3; setSunFromLonLat(sunLon, sunLat); uiSetStatus(`Sun Lon=${sunLon.toFixed(0)} Lat=${sunLat.toFixed(0)}`); }
            return;

          case "sunDown":
            if (sunMode === SunMode.MANUAL) { sunLat -= 3; setSunFromLonLat(sunLon, sunLat); uiSetStatus(`Sun Lon=${sunLon.toFixed(0)} Lat=${sunLat.toFixed(0)}`); }
            return;

          case "presetBright":
            FINAL_GAIN = 1.90; FINAL_CONTRAST = 1.10; globeScale = 0.90; spinSpeed = 0.18;
            uiSetStatus("Preset: Bright");
            return;

          case "presetDemo":
            FINAL_GAIN = 1.75; FINAL_CONTRAST = 1.08; globeScale = 0.88; spinSpeed = 0.25;
            uiSetStatus("Preset: Demo");
            return;

          case "presetNight":
            FINAL_GAIN = 1.55; FINAL_CONTRAST = 1.05; globeScale = 0.88; spinSpeed = 0.15;
            uiSetStatus("Preset: Night");
            return;

          case "presetReset":
            FINAL_GAIN = 1.70; FINAL_CONTRAST = 1.08; globeScale = 0.88; spinSpeed = 0.15;
            uiSetStatus("Preset: Reset");
            return;

          default:
            uiSetStatus(`Unknown: ${cmd}`);
            return;
        }
      }

      // Auto-hide reset on any interaction
      ["pointerdown","pointermove","touchstart","touchmove"].forEach(evtName => {
        uiPanel.addEventListener(evtName, () => armAutoHide(), { passive: true });
        uiBtn.addEventListener(evtName, () => armAutoHide(), { passive: true });
      });

      console.log("Touch UI initialised");
    })();
  </script>
</body>
</html>
